/*The code is used to mapping g to  G2 on BW13-P310
using Method I and II, where g is a fixed point.
Comparing the ouputs to the outputs of test_hash-BW13.c in
 C language implementation, we then can confirm the the C language
implementation is correct.

*/
P<u>:=PolynomialRing(RationalField());
z:=-2224;
p:=1749234309176102157657582860550885176950582224007184238236721873530271444092780\
387026731606667;
r:=2143085360734996117913472445644488914854141302995428209978212956147876055499508\
01;
t:=-72424742659885778123097924206425573989051009199;
Fp:=GF(p);
F13:=ext<Fp|u^13+2>;
/*w1,w2 are two primitive cube root over F^*_p*/
w1:=1060961839710140962051029043989073482206300122999381892347557062395216868763690\
225024943;
w2:=w1^2 mod p;
E:=EllipticCurve([F13|0,-17]);
a0:=0x2ABD462165DD51FE6C04FEDB34B5B10D73358C3E6402D59226DEF4DA1C7A1240C5C46C7C79500F;
a1:=0x58946AEB5E1C2537196E12B1765C7A3113BD577823FD7BDC56F9DB711CA3071C1676367F9491D;
a2:=0x29F4B088795B1C89F223B6CB69A7D699B1B06C4831DF540108A72F612095F79FC2170431EE3E69;
a3:=0x14B1E0C6C9C1C25B19A313FC5503CFCA12293A903C36BCBE545BB96BFE0E5E1EAC156DFC8FC5A6;
a4:=0x25FC28559B2C0D5A7F8DA3A7E081E42B6F4E126BC023D999ABB28695BC42C27492398390DCDD6D;
a5:=0x17AFB2B6F679FEA9EEB2B2ABF66E205F4CB2A23C160453DEA9EED5DDA437477D1C4609F4B07C4;
a6:=0x2D9AE5033103D87112FA4594003FC3BA449EF5E1FE4FDFC29A51C09B131B195BD82D46B88ACC8D;
a7:=0x1D2F2B5D02287C93BF737D5AE3AC431B113E69150F0E788A1D868E2A251AEE42D11D4DB347487A;
a8:=0x2D77538DB67FA0DABFDA27C95DD55880D0E8E77118AE732729A5250819CE9BA058B5A51620FECD;
a9:=0x4B0CCBA27BF29FDD864E99D111E2EAD803F973EB1A684508065785BF2EA3D8F2221518BA86E10;
a10:=0x8FAEBB1566640E9BEF4F12DFE21FF2137162BFE08EC3A814F2238000409EC355F3063C60C4B2E;
a11:=0x1B3C57505E53D39BFBF1DE9B8307D152E423CF9FA7B66209E44324654C3FD658EBC57CCA6FFFF3;
a12:=0x1F125EE2D5157BFEFE8571CAFFC2AE4E1062CB6526A87E3E9050D5375AB0F37ADE307C536E728F;
b0:=0x31DDFA3A93A3B02CB8B13D1F6C7D24A3877CF2600513DD4EF5DE6410724E987EB847F17D6BE89;
b1:=0x1107F6C78373AB0B5B36E458F3FA92641E8EA054E056C844B7493571D2F70CFCC13CBE2ADC17DE;
b2:=0x16533C0ADDEA6C2D79D6139696336D7E94FEE4798B56134955A29FD15F287FB334718989AE0EF6;
b3:=0x3DEC8837133A2F65C891E5886D034F6369D2FAFFC1BA67B0A4BFDDFEA4797593EC7B4ACBDDD1F;
b4:=0x6430620153331E78E27176AFE8D23B90AFDA73D62EC5F9BC9747EA4AFBD8814F6F2B3687CD3FF;
b5:=0x4D4FA058C308CCD65102F10E4B8E4FAE3ED106527359305BCFBEF66A350CD00F22F5D144DB215;
b6:=0x189652E6C505DEC2A21626A5ED529B898C89707A1557F765E548FA515CE2E947F37DFC9B4521D1;
b7:=0xB29DF623A04DB6DC7BB54036443E39153AD0ADD037050B1CA5C3BDAFFCA822A1A68C10D1DF72F;
b8:=0x33A0B68997C7577CD6114004D1ED3359661C49EEDDF0F8E55F631562E7AEE519E8E24CDDF28056;
b9:=0x1AAE620E614F63A1E5FB36D7ECDAFE0BAEF6F99E9C4B9DAD12CF00238C3B714E9C54E44153233C;
b10:=0x15B621B7135EC055E9ACC6981EF2105C75AB67AE8DB83CCD355E85082DEBC51028C38B79EE9576;
b11:=0x353D8EB9295630CD0CA815C0C76F7E3EE24AE4CBB0AA8B8652C3F617C88E71B9973D51432CA8D5;
b12:=0x17D1816D1D1DB07DE35570400B8CA6CABA2C01A50CF2B159CC1D1DC1B2A8302D052FB890006B12;

a:=a12*F13.1^12 + a11*F13.1^11 +a10*F13.1^10 + a9*F13.1^9 +a8*F13.1^8 + a7*F13.1^7 +
    a6*F13.1^6 + a5*F13.1^5 +a4*F13.1^4 + a3*F13.1^3 +a2*F13.1^2 + a1*F13.1+a0;
b:=b12*F13.1^12 + b11*F13.1^11 +b10*F13.1^10 + b9*F13.1^9 +b8*F13.1^8 + b7*F13.1^7 +
    b6*F13.1^6 + b5*F13.1^5 +b4*F13.1^4 + b3*F13.1^3 +b2*F13.1^2 + b1*F13.1+b0;
Q:=E![a,b,1];
/* endo is the efficiently computable enomorphism \psi^i=(\pi*\phi)^2, w
where \phi:(x,y)->(w1*x,y)*/
endo:=function(Q,i);
      if i mod 3 eq 0 then 
         R:=E![Frobenius(Q[1],Fp,i), Frobenius(Q[2],Fp,i),1];
      elif i mod 3 eq 1 then 
         R:=E![Frobenius(Q[1],Fp,i)*w1, Frobenius(Q[2],Fp,i),1];
     else
         R:=E![Frobenius(Q[1],Fp,i)*w2, Frobenius(Q[2],Fp,i),1];
    end if;
    return R;
end function;


/*hasing to G2 using Method II*/
    P:=E![Frobenius(Q[1],Fp,1),Frobenius(Q[2],Fp,1),1]-Q;
    P1:=z*P;P2:=P1-P;P3:=z*P1;
    R14:=2*P; R12:=P3-P2;
    R11:=-z*R12;R10:=-z*R11;R9:=-z*R10;R8:=-z*R9;
    R7:=-z*R8;R6:=-z*R7;R5:=-z*R6;R4:=-z*R5;
    R3:=-z*R4;R2:=-z*R3;R1:=-z*R2+P;
    U0:=(R1+R4+R7+R10-P1);
    U1:=(R3+R6+R9+R12);
    U2:=(R2+R5+R8+R11);
    R0:=U0-U1;R13:=U0-U2-P2;
    R:=R0+endo(R1,1)+endo(R2,2)+endo(R3,3)+endo(R4,4)+endo(R5,5)+endo(R6,6)+endo(R7,7)+endo(R8,8)
    +endo(R9,9)+endo(R10,10)+endo(R11,11)+endo(R12,12)+endo(R13,13)+endo(R14,14);
   printf"****************************mapping g to G2 using method II**************\n";
R;
/*check Method II is correct*/
T0:=R;T1:=r*R;T2:=E![Frobenius(R[1],Fp,1),Frobenius(R[2],Fp,1),1]-p*R;
if T0[3] ne 0 and T1[3] eq 0 and T2[3] eq 0 then
    printf"Method II is CORRECT!\n";
elif  T0[3] eq 0 then 
    printf"Reselect random point!\n" ;
else
    printf"ERROR -- Method II!\n";
end if;


/*hasing to G2 using Method I*/
    P:=E![Frobenius(Q[1],Fp,1),Frobenius(Q[2],Fp,1),1]-Q;
    S1:=z*P;S2:=z*S1; S3:=z*S2; S4:=z*S3;S5:=z*S4;S6:=z*S5;S7:=z*S6;
    S8:=z*S7;S9:=z*S8;S10:=z*S9;S11:=z*S10;S12:=z*S11;S13:=z*S12;S14:=z*S13;
    M0:=(2*S2+S1);M1:=(2*S5+S4);M2:=(2*S8+S7);M3:=(2*S11+S10);
    R0:=M0-P;H0:=2*S3-M0;R1:=M1-S3;H1:=2*S6-M1;
    R2:=M2-S6;H2:=2*S9-M2;R3:=M3-S9;H3:=2*S12-M3;

    L0:=(S14-S13+S12);L1:=z*L0;L2:=z*L1;L3:=z*L2;L4:=z*L3;
    L5:=z*L4;L6:=z*L5; L7:=z*L6;L8:=z*L7;L9:=z*L8;
    L10:=z*L9;L11:=z*L10;L12:=z*L11;
    K12:=L9-3*S9;
   
    K0:=L8+H2;K3:=-(L5+H1);K6:=L2+H0;
    K1:=R2;K4:=-R1;K7:=R0;
    K2:=-(L6-3*S6);K5:=(L3-3*S3);K8:=-(L0-3*P);
    K9:=-L12+3*(S12-P);
    K10:=-L11-H3;
    K11:=-R3;
R:=K0+E![Frobenius(K1[1],Fp,1),Frobenius(K1[2],Fp,1)]+E![Frobenius(K2[1],Fp,2),Frobenius(K2[2],Fp,2)]
+E![Frobenius(K3[1],Fp,3),Frobenius(K3[2],Fp,3)]+E![Frobenius(K4[1],Fp,4),Frobenius(K4[2],Fp,4)]
+E![Frobenius(K5[1],Fp,5),Frobenius(K5[2],Fp,5)]+E![Frobenius(K6[1],Fp,6),Frobenius(K6[2],Fp,6)]
+E![Frobenius(K7[1],Fp,7),Frobenius(K7[2],Fp,7)]+E![Frobenius(K8[1],Fp,8),Frobenius(K8[2],Fp,8)]
+E![Frobenius(K9[1],Fp,9),Frobenius(K9[2],Fp,9)]+E![Frobenius(K10[1],Fp,10),Frobenius(K10[2],Fp,10)]
+E![Frobenius(K11[1],Fp,11),Frobenius(K11[2],Fp,11)]+E![Frobenius(K12[1],Fp,12),Frobenius(K12[2],Fp,12)];
 printf"****************************mapping g to G2 using method I**************\n";
R;
/*check Method I is correct*/
T0:=R;T1:=r*R;T2:=E![Frobenius(R[1],Fp,1),Frobenius(R[2],Fp,1),1]-p*R;
if T0[3] ne 0 and T1[3] eq 0 and T2[3] eq 0 then
    printf"Method II is CORRECT!\n";
elif  T0[3] eq 0 then 
    printf"Reselect random point!\n" ;
else
    printf"ERROR -- Method II!\n";
end if;


